#include <iostream>
#include <time.h>
#include <stdlib.h>
#include <assert.h>

using namespace std;

/*
                                      Задача 6_4

 Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..10^9] размера n.
 Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции
 с индексом k ∈[0..n-1] в отсортированном массиве.
 Напишите нерекурсивный алгоритм.
 Требования к дополнительной памяти: O(n).
 Требуемое среднее время работы: O(n).
 Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
 Описание для случая прохода от начала массива к концу:
 Выбирается опорный элемент.
 Опорный элемент меняется с последним элементом массива.
 Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
 Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат
 нерассмотренные элементы. Последним элементом лежит опорный.
 Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
 Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
 Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного,
 то сдвигаем j. Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
 В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

 Реализуйте стратегию выбора опорного элемента “случайный элемент”.
 Функцию Partition реализуйте методом прохода двумя итераторами от
 конца массива к началу.
*/

int partition(int *array, int left, int right);
int kStatistics(int *array, const int k, int left, int right);

int main()
{
    int elements_count = 0, // количество элементов в массиве
    k = 0;              // позиция элемента

    // вводим количество элементов и позицию элемента
    cin >> elements_count >> k;
    // проверка на неотрицательный размер массива
    assert(elements_count > 0);

    // выделение памяти под массив
    int *array = new int[elements_count];

    // заполнение массива элементами
    for (int i = 0; i < elements_count; ++i)
    {
        int element;
        cin >> element;
        array[i] = element;
    }

    // вывести к-ю порядковую статистику
    cout << kStatistics(array, k, 0, elements_count - 1);

    delete []array;

    return 0;
}

int partition(int *array, int left, int right)
{
    // Выбор произвольного элемента массива и
    // замена его на первый элемент массива
    if (left != right)
        swap(array[left + rand() % (right - left)], array[left]);

    int x = array[left];

    // два счетчика справа
    int i = right + 1;

    for (int j = right; j >= left; --j)
        if (array[j] >= x)
            swap(array[--i], array[j]);

    return i;
}

int kStatistics(int *array, const int k, int left, int right)
{
    // рандом зависит от времени
    srand(time(NULL));

    while(1)
    {
        int position = partition(array, left, right);

        // если индекс меньше, то делаем проход по
        // правой части массива
        if (position < k)
            left = position + 1;

            // если наоборот, то по левой части
        else if (position > k)
            right = position - 1;

            // возвращаем искомый индекс
        else
            return array[k];
    }
}
